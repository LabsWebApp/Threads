// ManualResetEventSlim - изначально используется SpinWait блокировка на 1000 итераций, 
// после чего происходит синхронизация с помощью объекта ядра.
ManualResetEventSlim slim = new ManualResetEventSlim(false, 1000);

void Function()
{
    slim.Wait();
    Console.WriteLine($"Поток {Thread.CurrentThread.Name} начал работу.");
}

Thread[] threads = { new(Function), new (Function), new (Function), new (Function), new (Function) };

for (int i = 0; i < threads.Length; i++)
{
    threads[i].Name = i.ToString();
    threads[i].Start();
}

Console.ReadKey();
slim.Set();

// Delay.
Console.ReadKey();
/*
 * Когда вы используете обычные блокировки (мьютексы, критические секции и т.д.),
 * Операционная система переводит ваш поток в состояние WAIT и прерывает его,
 * планируя другие потоки на том же ядре. Это приводит к снижению производительности,
 * если время ожидания действительно мало, потому что ваш поток теперь должен ждать упреждения,
 * чтобы снова получить время ЦП.
 * Кроме того, объекты ядра доступны не во всех состояниях ядра, например, в обработчике прерываний,
 * когда подкачка недоступна и т.д.
 * Спинлоки не вызывают прерывание, но ждут в цикле ("вращение"), пока другое ядро не снимет блокировку.
 * Это предотвращает нить от потери ее кванта и продолжать, как только замок освобождается.
 * Простой механизм спин-блокировки позволяет ядру использовать его практически в любом состоянии.
 */